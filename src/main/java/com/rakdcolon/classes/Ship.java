package com.rakdcolon;

import java.util.*;

/**
 * This class is responsible for generating a ship on a grid.
 * It uses a random number generator to determine the positions of the cells in the grid.
 * The grid is represented as a boolean array where each cell can be either open (true) or closed (false).
 * The class also maintains a count of adjacent open cells for each cell in the grid.
 * The set of cells that are candidates to be opened next is stored in a set.
 */
public class Ship
{
    /**
     * The size of the grid (both width and height).
     */
    private static final int SIZE = Main.SIZE;
    
    /**
     * Random number generator used for various random operations.
     */
    private static final Random rand = new Random();
    
    /**
     * Array of directions used for navigating the grid.
     * The directions are: up, down, left, right.
     */
    private static final int[] DIRECTIONS = { -SIZE, SIZE, -1, 1 };
    
    /**
     * Boolean array representing the grid where each cell can be either open (true) or closed (false).
     */
    private final boolean[] grid;
    
    /**
     * Array representing the count of adjacent open cells for each cell in the grid.
     */
    private final int[] count;
    
    /**
     * Set of cells that are candidates to be opened next.
     */
    private final RandomizedSet toOpen;
    
    /**
     * Constructor for the ShipGeneration class.
     * It generates a ship on the grid by setting cells to be open.
     * The ship is generated by setting a random cell to be open and then setting adjacent cells with one adjacent open cell to be open.
     * The process is repeated until there are no more cells to be opened.
     * The ship is then completed by opening a some dead ends.
     */
    public Ship ()
    {
        int gridSize = SIZE * SIZE;
        
        grid = new boolean[gridSize];
        count = new int[gridSize];
        toOpen = new RandomizedSet();
        
        int randomCell = getRandomCell();
        setCell(randomCell, false);
        
        while (!toOpen.isEmpty())
        {
            int cell = toOpen.getRandom();
            setCell(cell, false);
            toOpen.remove(cell);
        }
        
        openDeadEnds();
    }
    
    public boolean isOpen(int index)
    {
        return grid[index];
    }
    
    /**
     * Opens dead-end cells in the grid.
     * A dead-end cell is defined as an open cell with exactly one adjacent open cell.
     * This method identifies such cells and adds their neighbors to the set of cells to be opened.
     * It then randomly opens half of the cells in the set.
     */
    private void openDeadEnds ()
    {
        for (int i = 0; i < SIZE * SIZE; i++)
        {
            if (grid[i] && count[i] == 1)
            {
                for (int direction : DIRECTIONS)
                {
                    int neighbor = i + direction;
                    int x = neighbor % SIZE;
                    int y = neighbor / SIZE;
                    if (withinBounds(x, y) && !grid[neighbor]) toOpen.add(neighbor);
                }
            }
        }
        
        int counter = toOpen.size() / 2;
        
        while (counter > 0) {
            int cell = toOpen.getRandom();
            toOpen.remove(cell);
            setCell(cell, true);
            counter--;
        }
    }
    
    
    /**
     * Sets a cell in the grid to be open.
     * If the cell is already open, the method returns immediately.
     * Otherwise, it marks the cell as open and updates the count of adjacent open cells for each neighbor.
     * If a neighbor has exactly one adjacent open cell, it is added to the set of cells to be opened.
     * If a neighbor has two or more adjacent open cells, it is removed from the set of cells to be opened.
     * If a neighbor has an invalid count (e.g., 5), an error message is printed.
     *
     * @param cell the index of the cell to be set as open
     */
    private void setCell(int cell, boolean isDeadEnd)
    {
        if (grid[cell])
        {
            throw new IllegalStateException("Cell already open: " + cell);
        }
        
        grid[cell] = true;
        
        for (int direction : DIRECTIONS)
        {
            int neighbor = cell + direction;
            int x = neighbor % SIZE;
            int y = neighbor / SIZE;
            if (!withinBounds(x, y)) continue;
            
            count[neighbor]++;
            
            if (grid[neighbor] || isDeadEnd) continue;
            
            if (count[neighbor] == 1)
            {
                toOpen.add(neighbor);
            }
            else if (count[neighbor] >= 2)
            {
                toOpen.remove(neighbor);
            }
        }
    }
    
    /**
     * Returns a random cell in the grid.
     * The cell is guaranteed to be within the bounds of the grid.
     *
     * @return a random cell in the grid
     */
    public int getRandomCell()
    {
        int x = rand.nextInt(1, SIZE - 1);
        int y = rand.nextInt(1, SIZE - 1);
        
        if (!withinBounds(x, y))
        {
            System.err.println("Invalid random cell: " + x + ", " + y);
        }
        
        return y * SIZE + x;
    }
    
    /**
     * Checks if a cell is within the bounds of the grid.
     *
     * @param x the x-coordinate of the cell
     * @param y the y-coordinate of the cell
     * @return true if the cell is within the bounds of the grid, false otherwise
     */
    public boolean withinBounds(int x, int y)
    {
        return x > 0 && x < SIZE - 1 && y > 0 && y < SIZE - 1;
    }
    
    /**
     * Returns the grid as a string.
     * The grid is represented as a string where each cell is either open (red) or closed (black).
     * The count of adjacent open cells for each cell is also displayed.
     *
     * @return the grid as a string
     */
    @Override
    public String toString()
    {
        StringBuilder sb = new StringBuilder();
        for (int y = 0; y < SIZE; y++)
        {
            for (int x = 0; x < SIZE; x++)
            {
                int index = y * SIZE + x;
                
                if (grid[index])
                {
                    sb.append("\033[31m").append(count[index]).append("\033[0m").append(" ");
                }
                else
                {
                    sb.append("\033[30m").append(count[index]).append("\033[0m").append(" ");
                }
            }
            sb.append("\n");
        }
        return sb.toString();
    }
}
